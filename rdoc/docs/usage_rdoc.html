<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

	<title>File: usage.rdoc [Nice-FFI 0.4 Docs]</title>

	<link type="text/css" media="screen" href="../rdoc.css" rel="stylesheet" />

	<script src="../js/jquery.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/thickbox-compressed.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/quicksearch.js" type="text/javascript"
		charset="utf-8"></script>
	<script src="../js/darkfish.js" type="text/javascript"
		charset="utf-8"></script>
</head>

<body class="file">
	<div id="metadata">
		<div id="project-metadata">
			
			
			<div id="fileindex-section" class="section project-section">
				<h3 class="section-header">Files</h3>
				<ul>
				
					<li class="file"><a href="../README_rdoc.html">README.rdoc</a></li>
				
					<li class="file"><a href="../TODO_rdoc.html">TODO.rdoc</a></li>
				
					<li class="file"><a href="../docs/usage_rdoc.html">usage.rdoc</a></li>
				
				</ul>
			</div>
			

			<div id="classindex-section" class="section project-section">
				<h3 class="section-header">Class Index
					<span class="search-toggle"><img src="../images/find.png"
						height="16" width="16" alt="[+]"
						title="show/hide quicksearch" /></span></h3>
				<form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
				<fieldset>
					<legend>Quicksearch</legend>
					<input type="text" name="quicksearch" value=""
						class="quicksearch-field" />
				</fieldset>
				</form>

				<ul class="link-list">
				
					<li><a href="../NiceFFI.html">NiceFFI</a></li>
				
					<li><a href="../NiceFFI/AutoRelease.html">NiceFFI::AutoRelease</a></li>
				
					<li><a href="../NiceFFI/Library.html">NiceFFI::Library</a></li>
				
					<li><a href="../NiceFFI/OpaqueStruct.html">NiceFFI::OpaqueStruct</a></li>
				
					<li><a href="../NiceFFI/PathSet.html">NiceFFI::PathSet</a></li>
				
					<li><a href="../NiceFFI/Struct.html">NiceFFI::Struct</a></li>
				
					<li><a href="../NiceFFI/TypedPointer.html">NiceFFI::TypedPointer</a></li>
				
				</ul>
				<div id="no-class-search-results" style="display: none;">No matching classes.</div>
			</div>

			
		</div>
	</div>

	<div id="documentation">
		<h1>Using Nice-FFI</h1>
<p>
This is a guide on how to use Nice-FFI&#8217;s features. It assumes that
you are already somewhat familiar with Ruby-FFI.
</p>
<h2><a href="../NiceFFI/Library.html">NiceFFI::Library</a></h2>
<p>
<a href="../NiceFFI/Library.html">NiceFFI::Library</a> is a drop-in
replacement for FFI::Library. It provides improved library finding
abilities and support for TypedPointer return types for attached functions.
</p>
<p>
In fact, <a href="../NiceFFI/Library.html">NiceFFI::Library</a> <b>is</b>
FFI::Library, but with a few extras. That means that you can do all the
regular FFI::Library stuff as well as the stuff described here.
</p>
<h3>load_library</h3>
<p>
<a href="../NiceFFI/Library.html#M000053">NiceFFI::Library.load_library</a>
is a more convenient replacement for FFI::Library.ffi_lib. It uses <a
href="../NiceFFI/PathSet.html">NiceFFI::PathSet</a> to search for the
library in the most likely places, depending on the user&#8217;s operating
system. For example, on Linux it would look for &#8220;lib[NAME].so&#8221;
in &#8220;/usr/lib/&#8220; (among others), while on Windows it would look
for &#8220;[NAME].dll&#8221; in &#8220;C:windowssystem32".
</p>
<p>
Using load_library is easy. Just use &#8220;extend NiceFFI::Library&#8221;
instead of &#8220;extend FFI::Library&#8221;, and use
&#8220;load_library&#8220; instead of &#8220;ffi_lib&#8220;:
</p>
<pre>
  require 'nice-ffi'

  module MyLibraryModule
    extend NiceFFI::Library

    load_library(&quot;SDL&quot;)  # look for libSDL.so, SDL.dll, etc.

    # structs, functions, etc. as usual.

  end
</pre>
<h4>Advanced load_library</h4>
<p>
As mentioned, load_library uses <a
href="../NiceFFI/PathSet.html">NiceFFI::PathSet</a> to search for the
library in likely directories. Specifically, it looks for:
</p>
<pre>
  paths = {
    /linux|bsd/  =&gt; [ &quot;/usr/local/lib/&quot;,
                      &quot;/usr/lib/&quot; ],

    /darwin/     =&gt; [ &quot;/usr/local/lib/&quot;,
                      &quot;/sw/lib/&quot;,
                      &quot;/opt/local/lib/&quot;,
                      &quot;~/Library/Frameworks/&quot;,
                      &quot;/Library/Frameworks/&quot; ],

    /windows/    =&gt; [ &quot;C:\\windows\\system32\\&quot;,
                      &quot;C:\\windows\\system\\&quot; ]
  }

  files = {
    /linux|bsd/  =&gt; [ &quot;lib[NAME].so*&quot;,
                      &quot;lib[NAME]-*.so*&quot; ],

    /darwin/     =&gt; [ &quot;lib[NAME].dylib&quot;,
                      &quot;lib[NAME]-*.dylib&quot;,
                      &quot;[NAME].framework/[NAME]&quot; ],

    /windows/    =&gt; [ &quot;[NAME].dll&quot;,
                      &quot;[NAME]-*.dll&quot;]
  }

  NiceFFI::PathSet::DEFAULT = NiceFFI::PathSet.new( paths, files )
</pre>
<p>
The paths hash tells PathSet where to look for libraries, and the files
hash tells it the format of the library filename itself. The string
&#8220;[NAME]&#8221; is replaced with whatever string you pass to
load_library.
</p>
<p>
Each key in the hash should be a Regexp that matches an OS name from
FFI::Platform::OS. As of this writing (October 2009), the list of
recognized OS names is:
</p>
<ul>
<li>&#8220;darwin&#8221; (MacOS X)

</li>
<li>&#8220;freebsd&#8220;

</li>
<li>&#8220;linux&#8220;

</li>
<li>&#8220;openbsd&#8220;

</li>
<li>&#8220;solaris&#8220;

</li>
<li>&#8220;windows&#8220;

</li>
</ul>
<p>
So, if the user is running Linux and you try to load &#8220;SDL&#8221;, it
will first look for &#8220;/usr/local/lib/libSDL.so&#8220;. If it
can&#8217;t find that, it will then look for
&#8220;/usr/lib/libSDL.so&#8220;. It would also use those same paths for
FreeBSD or OpenBSD, because those OS names also match the regexp
/linux|bsd/.
</p>
<p>
If the library could not be found in any of the given directories with the
given file name formats, load_library will just try loading
&#8220;SDL&#8221; using ffi_lib (which does some platform-appropriate
guesses too). If that fails too, LoadError is raised.
</p>
<p>
If you want to load from a different path, you can make a custom PathSet
and pass it to load_library:
</p>
<pre>
  libs_dir = File.dirname(__FILE__) + &quot;/libs/&quot;

  pathset = NiceFFI::PathSet::DEFAULT.prepend( libs_dir )

  load_library( &quot;SDL&quot;, my_pathset )
</pre>
<p>
The above example prepends (adds in front) the new paths so that
load_library will look for the library in &#8220;./libs/&#8221; first. See
PathSet for other useful methods for modifying PathSets.
</p>
<p>
Another advanced usage tip: If a library has several alternative names, you
can provide an Array of names:
</p>
<pre>
  # It might be called &quot;foo&quot;, &quot;foo2&quot;, or &quot;Foo&quot;.

  load_library( [&quot;foo&quot;, &quot;foo2&quot;, &quot;Foo&quot;] )
</pre>
<h3>attach_function</h3>
<p>
<a
href="../NiceFFI/Library.html#M000054">NiceFFI::Library#attach_function</a>
behaves similarly to FFI::Library#attach_function, except it supports
TypedPointer return values. For example, suppose you have a C function:
</p>
<pre>
  MyStruct *make_my_struct( int x, int y );
</pre>
<p>
This returns a pointer to an instance of MyStruct. With FFI, you&#8217;d
write this to attach it:
</p>
<pre>
  attach_function :make_my_struct, [:int, :int], :pointer
</pre>
<p>
And when you called it, it would return an FFI::Pointer, which you would
then have to manually wrap every time you called the method:
</p>
<pre>
  ptr = make_my_struct( 1, 2 )
  mystruct = MyStruct.new( ptr )
</pre>
<p>
With TypedPointer, the wrapping happens automatically. Just attach the
function with a TypedPointer instead of :pointer:
</p>
<pre>
  attach_function :make_my_struct, [:int, :int], NiceFFI::TypedPointer( MyStruct )

  # If MyStruct is based on NiceFFI::Struct, you can do this instead:

  attach_function :make_my_struct, [:int, :int], MyStruct.typed_pointer
</pre>
<p>
Then you automatically get a MyStruct instance when you call the function:
</p>
<pre>
  mystruct = make_my_struct( 1, 2 )
  mystruct.instance_of?( MyStruct )   # =&gt;  Heck yeah it sure is!
</pre>
<p>
Voila!
</p>
<h2><a href="../NiceFFI/Struct.html">NiceFFI::Struct</a></h2>
<p>
<a href="../NiceFFI/Struct.html">NiceFFI::Struct</a> is a replacement for
FFI::Struct. It provides several features in addition to the normal
FFI::Struct behavior:
</p>
<ul>
<li>Ability to construct new instances from Array, Hash, another instance, or a
pointer as usual.

</li>
<li>Automatic read and write accessors for struct members.

</li>
<li>Accessors for struct pointer members with TypedPointer.

</li>
<li>Ability to dump an instance as an Array (to_ary) or Hash (to_hash).

</li>
<li>Pretty and useful to_s and inspect for debugging.

</li>
</ul>
<h3>Constructors</h3>
<p>
<a href="../NiceFFI/Struct.html">NiceFFI::Struct</a> allows you to
construct a new struct instance from a Hash, Array, or another existing
instance of the same struct type. It can also accept a pointer, just as
with FFI::Struct.
</p>
<pre>
  class MyStruct &lt; NiceFFI::Struct
    layout :x, :int,
           :y, :int
  end

  mystruct  = MyStruct.new( {:x =&gt; 1, :y =&gt; 2} )  # from Hash
  mystruct2 = MyStruct.new( [1,2] )               # from Array
  mystruct3 = MyStruct.new( mystruct )            # from another instance
  mystruct4 = MyStruct.new( ptr )                 # from Pointer
</pre>
<h3>Struct Member Accessors</h3>
<p>
Struct members are defined automatically when you use <a
href="../NiceFFI/Struct.html#M000021">NiceFFI::Struct.layout</a>:
</p>
<pre>
  class MyStruct &lt; NiceFFI::Struct
    layout :x, :int,
           :y, :int
  end

  mystruct = MyStruct.new({:x =&gt; 1, :y =&gt; 2})

  mystruct.x  # =&gt; 1
  mystruct.y  # =&gt; 2

  mystruct.x =  3
  mystruct.y = -4
</pre>
<p>
Sometimes a struct will have members that should be read-only, or
completely hidden. In those cases, you can use <a
href="../NiceFFI/Struct.html#M000024">NiceFFI::Struct.read_only</a> and <a
href="../NiceFFI/Struct.html#M000022">NiceFFI::Struct.hidden</a>.
</p>
<pre>
  class MySneakyStruct &lt; NiceFFI::Struct
    layout :readme,  :int,
           :readme2, :int,
           :hideme,  :pointer,
           :hideme2, :pointer,
           :normal,  :uint32

    read_only :readme, :readme2
    hidden    :hideme, :hideme2
  end

  sneaky = MySneakyStruct.new( ... )
</pre>
<p>
read_only prevents a write accessor from being created (or removes it if
there is already one). hidden does the same, but for both read and write
accessors. hidden also prevents the member from being shown in to_s and
inspect.
</p>
<p>
read_only and hidden can go before or after layout (or both), and you can
safely call them multiple times if you need to.
</p>
<h3>TypedPointer Struct Member Accessors</h3>
<p>
Some struct members are :pointers that point to other structs. With
FFI::Struct, you&#8217;d have to manually wrap and unwrap the struct
pointer, but if you specify a TypedPointer instead of :pointer, <a
href="../NiceFFI/Struct.html">NiceFFI::Struct</a> will wrap and unwrap it
automatically:
</p>
<pre>
  class StructWithPtr &lt; NiceFFI::Struct
    layout :x,  :int,
           :y,  :int,
           :my, NiceFFI::TypedPointer( MyStruct )
  end

  struct = StructWithPtr.new( :x  =&gt; -1,
                              :y  =&gt; -2,
                              :my =&gt; MyStruct.new([1,2]) )

  # Seamlessly wraps the pointer in a struct
  struct.my.kind_of? MyStruct           # true

  # Seamlessly unwraps the struct and stores the pointer
  struct.my = MyStruct.new([-4,-3])
</pre>
<h3>Automatic Memory Managment</h3>
<p>
Ruby-FFI already provides automatic memory management when you create a
FFI::MemoryPointer or FFI::Buffer instance. When those instances are
garbage collected, their memory is automatically released so it can be used
elsewhere.
</p>
<p>
That feature is used by <a
href="../NiceFFI/Struct.html">NiceFFI::Struct</a> when you create a new
instance by passing a Hash, Array, String, or another instance. In those
cases, new memory is allocated for the struct instance, and automatically
released when the struct instance is galbage collected.
</p>
<p>
<a href="../NiceFFI/Struct.html">NiceFFI::Struct</a> also provides an
optional automatic memory management system for normal pointers. To use
this system, define a &#8220;release&#8221; class method in your class.
Then if you create a new struct instance with an FFI::Pointer, the release
class method will automatically be called when the memory for a struct
instance needs to be freed.
</p>
<p>
(This also applies to attached functions with TypedPointer return values.
The pointers returned from those functions are wrapped in the struct class,
so if you have defined the release class method, they will be automatically
memory managed.)
</p>
<p>
The release class method must accept an FFI::Pointer and call an
appropriate function to free the struct&#8217;s memory. Here&#8217;s an
example from Ruby-SDL-FFI:
</p>
<pre>
  class Surface &lt; NiceFFI::Struct

    def self.release( pointer )
      SDL.FreeSurface( pointer )
    end

    # ...

  end
</pre>
<p>
Note: the release class method should not have any side effects besides
freeing the struct&#8217;s memory. Don&#8217;t be clever!
</p>
<p>
The memory management system keeps a reference count for each pointer
address, so the release class method will only be called when all struct
instances that are using that memory have been garbage collected. That
means it&#8217;s safe to have many instances sharing the same memory.
</p>
<p>
If you want to create an instance that doesn&#8217;t use the memory
management system, you can disable the :autorelease option when creating
the instance, like so:
</p>
<pre>
  struct = MyStructClass.new( a_pointer, :autorelease =&gt; false )
</pre>
<h2><a href="../NiceFFI/OpaqueStruct.html">NiceFFI::OpaqueStruct</a></h2>
<p>
Some C libraries have structs with no publicly-visible layout. Instead, the
internal details are hidden, and only modified by calling functions in the
library.
</p>
<p>
For example, the SDL_mixer library has this definition in its header file:
</p>
<pre>
  typedef struct _Mix_Music Mix_Music;
</pre>
<p>
&#8220;_Mix_Music&#8220; is a struct that is defined within SDL_mixer, but
its internals are different depending on what features SDL_mixer was
compiled with. The struct members are not revealed in the header file, so
they can&#8217;t be accessed like a normal struct.
</p>
<p>
<a href="../NiceFFI.html">NiceFFI</a> provides a class for handling special
cases like this, <a
href="../NiceFFI/OpaqueStruct.html">NiceFFI::OpaqueStruct</a>. OpaqueStruct
has no layout and no members, and cannot be created by passing in Hashes,
Arrays, etc. It simply holds a pointer to the struct memory. As with
NiceStruct (and FFI::Struct), instances of OpaqueStruct-based classes can
be passed directly to functions expecting a pointer of the appropriate
struct type.
</p>
<p>
OpaqueStruct features the same optional memory management system as
NiceStruct. Read the &#8220;Automatic Memory Management&#8221; section
above for information about how to use this feature.
</p>

	</div>

	<div id="validator-badges">
		<p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
		<p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
			Rdoc Generator</a> 1.1.6</small>.</p>
	</div>
</body>
</html>

